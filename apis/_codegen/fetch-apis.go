package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"sort"
	"sync"

	got "github.com/taskcluster/go-got"
	"github.com/taskcluster/taskcluster-cli/apis/definitions"
)

func main() {
	// synchronization objects
	mutex := &sync.Mutex{}
	wg := &sync.WaitGroup{}

	g := got.New()

	var gen generator

	gen.Printf("// Code generated by codegen; DO NOT EDIT\n")
	gen.Printf("package apis\n")
	gen.Printf("\n")
	gen.Printf("import \"github.com/taskcluster/taskcluster-cli/apis/definitions\"\n")
	gen.Printf("\n")

	// Fetch API manifest
	res, err := g.Get("http://references.taskcluster.net/manifest.json").Send()
	if err != nil {
		log.Fatalln("error: failed to fetch api manifest: ", err)
	}
	// Parse API manifest
	var manifest map[string]string
	if err = json.Unmarshal(res.Body, &manifest); err != nil {
		log.Fatalln("error: failed to parse api manifest: ", err)
	}

	fmt.Println("Fetching Services:")
	services := make(map[string]definitions.Service)
	for name, referenceURL := range manifest {
		wg.Add(1)
		go func(n string, u string) {
			s := fetchService(g, n, u)

			mutex.Lock()
			services[n] = s
			mutex.Unlock()
			wg.Done()
		}(name, referenceURL)
	}
	wg.Wait()

	gen.Printf("var services = map[string]%v{\n", "definitions.Service")
	sortedNames := make([]string, 0, len(services))
	for n := range services {
		sortedNames = append(sortedNames, n)
	}
	sort.Strings(sortedNames)
	for _, name := range sortedNames {
		gen.Printf("\"%s\": %#v,\n", name, services[name])
	}
	gen.Printf("}\n")
	gen.Printf("\n")

	// Fetch all schemas
	fmt.Println("Fetching Schemas:")
	schemas := make(map[string]string, 0)
	urls := make(map[string]bool, 0)

	addSchema := func(url string) {
		if url == "" || urls[url] {
			return
		}

		urls[url] = true
		wg.Add(1)
		go func() {
			s := fetchSchema(g, url)

			mutex.Lock()
			schemas[url] = s
			mutex.Unlock()
			wg.Done()
		}()
	}
	for _, s := range services {
		for _, e := range s.Entries {
			addSchema(e.Input)
			addSchema(e.Output)
		}
	}
	wg.Wait()

	gen.Printf("var schemas = map[string]%v{\n", "string")
	sortedUrls := make([]string, 0, len(urls))
	for k := range urls {
		sortedUrls = append(sortedUrls, k)
	}
	sort.Strings(sortedUrls)
	for _, u := range sortedUrls {
		gen.Printf("\"%s\": %#v,\n", u, schemas[u])
	}
	gen.Printf("}\n")

	// Format the output.
	source, err := gen.Format()
	if err != nil {
		log.Println(gen.String())
		log.Fatalln("error: go fmt, code generation failed: ", err)
	}

	if err := ioutil.WriteFile("services.go", source, 0664); err != nil {
		log.Fatalln("error: failed to save services.go: ", err)
	}
}

func fetchService(g *got.Got, name string, url string) definitions.Service {
	fmt.Println(" - Fetching", name)
	// Fetch reference
	res, err := g.Get(url).Send()
	if err != nil {
		log.Fatalln("error: failed to fetch API ", name, ": ", err)
	}
	// Parse reference
	var s definitions.Service
	if err := json.Unmarshal(res.Body, &s); err != nil {
		log.Fatalln("error: failed parse API ", name, ": ", err)
	}
	return s
}

func fetchSchema(g *got.Got, url string) string {
	fmt.Println(" - ", url)
	res, err := g.Get(url).Send()
	if err != nil {
		log.Fatalln("error: failed to fetch ", url, ": ", err)
	}
	// Test that we can parse the JSON schema (otherwise it's invalid)
	var i interface{}
	if err := json.Unmarshal(res.Body, &i); err != nil {
		log.Fatalln("error: failed to parse ", url, ": ", err)
	}
	return string(res.Body)
}

// generator holds a buffer of the output that will be generated.
type generator struct {
	buf bytes.Buffer
}

// Printf prints the given format+args to the buffer.
func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the formated contents of the generator's buffer.
func (g *generator) Format() ([]byte, error) {
	return format.Source(g.buf.Bytes())
}

func (g *generator) String() string {
	return g.buf.String()
}
