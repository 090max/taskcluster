package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"reflect"
	"sort"
	"sync"

	got "github.com/taskcluster/go-got"
	"github.com/taskcluster/taskcluster-cli/apis/definitions"
)

func main() {
	// synchronization objects
	mutex := &sync.Mutex{}
	wg := &sync.WaitGroup{}

	g := got.New()

	gen := &generator{}

	gen.Print("// Code generated by codegen; DO NOT EDIT\n")
	gen.Print("package apis\n")
	gen.Print("\n")
	gen.Print("import \"github.com/taskcluster/taskcluster-cli/apis/definitions\"\n")
	gen.Print("\n")

	// Fetch API manifest
	res, err := g.Get("http://references.taskcluster.net/manifest.json").Send()
	if err != nil {
		log.Fatalln("error: failed to fetch api manifest: ", err)
	}
	// Parse API manifest
	var manifest map[string]string
	if err = json.Unmarshal(res.Body, &manifest); err != nil {
		log.Fatalln("error: failed to parse api manifest: ", err)
	}

	fmt.Println("Fetching Services:")
	services := make(map[string]definitions.Service)
	for name, referenceURL := range manifest {
		wg.Add(1)
		go func(n string, u string) {
			s := fetchService(g, n, u)

			mutex.Lock()
			services[n] = s
			mutex.Unlock()
			wg.Done()
		}(name, referenceURL)
	}
	wg.Wait()

	gen.Print("var services = ")
	gen.PrintComposite(services, true)
	gen.Print("\n")

	// Fetch all schemas
	fmt.Println("Fetching Schemas:")
	schemas := make(map[string]string, 0)
	urls := make(map[string]bool, 0)

	addSchema := func(url string) {
		if url == "" || urls[url] {
			return
		}

		urls[url] = true
		wg.Add(1)
		go func() {
			s := fetchSchema(g, url)

			mutex.Lock()
			schemas[url] = s
			mutex.Unlock()
			wg.Done()
		}()
	}
	for _, s := range services {
		for _, e := range s.Entries {
			addSchema(e.Input)
			addSchema(e.Output)
		}
	}
	wg.Wait()

	gen.Print("var schemas = ")
	gen.PrintComposite(schemas, true)
	gen.Print("\n")

	// Format the output.
	source, err := gen.Format()
	if err != nil {
		log.Println(gen.String())
		log.Fatalln("error: go fmt, code generation failed: ", err)
	}

	if err := ioutil.WriteFile("services.go", source, 0664); err != nil {
		log.Fatalln("error: failed to save services.go: ", err)
	}
}

func fetchService(g *got.Got, name string, url string) definitions.Service {
	fmt.Println(" - Fetching", name)
	// Fetch reference
	res, err := g.Get(url).Send()
	if err != nil {
		log.Fatalln("error: failed to fetch API ", name, ": ", err)
	}
	// Parse reference
	var s definitions.Service
	if err := json.Unmarshal(res.Body, &s); err != nil {
		log.Fatalln("error: failed parse API ", name, ": ", err)
	}
	return s
}

func fetchSchema(g *got.Got, url string) string {
	fmt.Println(" - ", url)
	res, err := g.Get(url).Send()
	if err != nil {
		log.Fatalln("error: failed to fetch ", url, ": ", err)
	}
	// Test that we can parse the JSON schema (otherwise it's invalid)
	var i interface{}
	if err := json.Unmarshal(res.Body, &i); err != nil {
		log.Fatalln("error: failed to parse ", url, ": ", err)
	}
	return string(res.Body)
}

// generator holds a buffer of the output that will be generated.
type generator struct {
	buf bytes.Buffer
}

func (g *generator) Write(p []byte) (n int, err error) {
	return g.buf.Write(p)
}

// Printf prints the given format+args to the buffer.
func (g *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// Print prints the given a to the buffer.
func (g *generator) Print(a ...interface{}) {
	fmt.Fprint(&g.buf, a...)
}

func (g *generator) PrintComposite(data interface{}, sorted bool) {
	v := reflect.ValueOf(data)
	t := v.Type()

	switch v.Kind() {
	case reflect.Array, reflect.Slice:
		// do stuff
		g.Printf("%s", t.String())
		if v.Kind() == reflect.Slice && v.IsNil() {
			g.Printf("(nil)")
			break
		}
		g.Print("{\n")
		for i := 0; i < v.Len(); i++ {
			g.PrintComposite(v.Index(i).Interface(), sorted)
			g.Print(",\n")
		}
		g.Print("}")
	case reflect.Struct:
		// then struct
		g.Printf("%s{\n", t.String())
		for i := 0; i < v.NumField(); i++ {
			g.Printf("%s: ", t.Field(i).Name)
			g.PrintComposite(v.Field(i).Interface(), sorted)
			g.Print(",\n")
		}
		g.Print("}")
	case reflect.Map:
		// finally map
		g.Printf("%s{\n", t.String())
		keys := v.MapKeys()
		if len(keys) == 0 {
			g.Print("}")
			break
		}
		if sorted && t.Key().Kind() == reflect.String {
			sortedK := make([]string, 0, len(keys))
			for _, k := range keys {
				sortedK = append(sortedK, k.String())
			}
			sort.Strings(sortedK)
			for i := range sortedK {
				k := reflect.ValueOf(sortedK[i])
				g.Printf("%#v: ", sortedK[i])
				g.PrintComposite(v.MapIndex(k).Interface(), sorted)
				g.Print(",\n")
			}
		} else {
			for i := 0; i < v.Len(); i++ {
				k := keys[i]
				g.Printf("%#v: ", k)
				g.PrintComposite(v.MapIndex(k).Interface(), sorted)
				g.Print(",\n")
			}
		}
		g.Print("}")
	default:
		g.Printf("%#v", v.Interface())
	}
}

// format returns the formated contents of the generator's buffer.
func (g *generator) Format() ([]byte, error) {
	return format.Source(g.buf.Bytes())
}

func (g *generator) String() string {
	return g.buf.String()
}
