# Chain of Trust

Chain of Trust is one of our safeguards for security-sensitive tasks. It exists to provide a second factor, in addition to taskcluster scopes, to verify that:

1. Requests to run security sensitive tasks can be traced back to commits in a trusted repository.
2. The environment in which those sensitive tasks run is trusted.
3. The artifacts generated from those tasks have not been modified at rest.

If a security sensitive task depends on the artifacts generated by another task, that upstream task is also considered a security sensitive task.

## Worker requirements

Currently, docker-worker and generic-worker generate artifacts used in Chain of Trust verification. These are the requirements for Chain of Trust generation.

### certified.log

At the end of a task, but before uploading artifacts, copy the task log to a static log file named `certified.log`. We will generate checksums for this file, and upload it to `public/logs/certified.log`.

The purpose of `certified.log` is for human auditing of the logfile of the task. Because the checksum is baked into the Chain of Trust artifact, we have assurances that no one has altered this log post-upload. (If we generate a checksum for `live_backing.log` but continue appending to it after generating the checksum but before upload, we will have an invalid checksum for an otherwise valid artifact. If we stop logging to `live_backing.log` after generating its checksum but before upload, we may lose error messages or warnings post-checksum-generation.)

### Chain of Trust artifact

At the end of the task, after generating `certified.log`, we create a Chain of Trust artifact with metadata about the task and its artifacts that allow us to verify the task, its inputs, and its outputs.

This artifact will be uploaded to `public/chain-of-trust.json`. We are using  [Chain of Trust artifact schema v1](https://github.com/mozilla-releng/scriptworker/blob/master/scriptworker/data/cot_v1_schema.json).

Details:

- `chainOfTrustVersion` refers to the CoT artifact schema version.
- `artifacts` contains a dictionary of artifacts and their checksums:

    ```
    "artifacts": {
        "public/logs/certified.log": {
            "sha256": "9877e6e5c27a859eed2c8f5b2b17e01aea9d0187bd828e603e7fa77e58b70285"
        },
        ...
    }
    ```

    We currently support sha256 and sha512 as valid algorithms. We're considering adding both checksums, as well as the filesize, to the Chain of Trust artifact.

    Because we expect `live.log` and `live_backing.log` to change after checksum generation, we exclude them from the artifacts dictionary.

- `task` contains the task definition.
- `taskId` contains the taskID.
- `runId` contains the runID.
- `workerGroup`, `workerId`, and `environment` contain metadata about the worker that ran the task, to allow for auditing.

    - In docker-worker tasks, we use `environment.imageHash` to specify the hash of the docker image that ran. There are three hashes for docker images:

        1. the artifact hash, e.g. the sha256 of image.tar.xz
        2. the image layer hash, which was used historically but allowed for image content tampering without detection, and
        3. [content addressable ids](https://windsock.io/explaining-docker-image-ids/), which hash up the contents of the image. We can get this via

            `docker inspect --format='{{.RepoDigests}}' $IMAGE`
            
            or
            
            `docker images --digests`

        We currently use the third option, the content addressable id / digest, as the `imageHash`.

    - We have included `publicIpAddress`, `privateIpAddress`, `instanceId`, `instanceType`, and `region` to docker-worker and generic-worker environment metadata, as metadata that could be helpful in auditing or debugging issues. There is no strict schema here at the moment, should the set of useful metadata change.

We currently prefer if the `chain-of-trust.json` artifact is indented for easier human readability. (We also previously hit a gpg line length limit issue, but we no longer use gpg to sign the CoT artifact.)

### Chain of Trust signature

In a subset of cases, we generate a detached ed25519 signature of the Chain of Trust artifact. This signature is uploaded as `public/chain-of-trust.json.sig` .

In our development and CI worker pools, we ignore signature verification, so we don't need to generate the signature, though it isn't harmful to do so. In our trusted release worker pools, we require that the Chain of Trust artifact is signed by a valid ed25519 key.

#### Security of the private key

Because the ed25519 private key acts as our second factor, we need to safeguard the security of the private key.

- This is our second factor to help secure Taskcluster scopes. Therefore, maintainers should not be able to access this secret without some credentials other than Taskcluster scopes.
- The file should be read-only, and only readable by the worker user.
- The task user must not be able to read the file.
- By limiting the release key to release-only workerTypes, and by limiting which users, repos, and tasks have scopes to launch release-only workerTypes, we limit which tasks can run on those pools.
- We should limit any access to the private key by humans.

## Chain of Trust verification

Chain of Trust verification is currently limited to scriptworkers. However, it would be more secure to verify the chain in each task, rather than just when a scriptworker task runs. In addition, if there is something that breaks Chain of Trust verification in the release taskgraph, we would detect that earlier in the graph, rather than breaking in the first scriptworker task.

At some point we will likely add Chain of Trust verification support to the official taskcluster worker implementations.
