{
  "version": "0.2.0",
  "title": "Task Index API Documentation",
  "description": "The task index, typically available at `index.taskcluster.net`, is\nresponsible for indexing tasks. In order to ensure that tasks can be\nlocated by recency and/or arbitrary strings. Common use-cases includes\n\n * Locate tasks by git or mercurial `<revision>`, or\n * Locate latest task from given `<branch>`, such as a release.\n\n**Index hierarchy**, tasks are indexed in a dot `.` separated hierarchy\ncalled a namespace. For example a task could be indexed in\n`<revision>.linux-64.release-build`. In this case the following\nnamespaces is created.\n\n 1. `<revision>`, and,\n 2. `<revision>.linux-64`\n\nThe inside the namespace `<revision>` you can find the namespace\n`<revision>.linux-64` inside which you can find the indexed task\n`<revision>.linux-64.release-build`. In this example you'll be able to\nfind build for a given revision.\n\n**Task Rank**, when a task is indexed, it is assigned a `rank` (defaults\nto `0`). If another task is already indexed in the same namespace with\nthe same lower or equal `rank`, the task will be overwritten. For example\nconsider a task indexed as `mozilla-central.linux-64.release-build`, in\nthis case on might choose to use a unix timestamp or mercurial revision\nnumber as `rank`. This way the latest completed linux 64 bit release\nbuild is always available at `mozilla-central.linux-64.release-build`.\n\n**Indexed Data**, when a task is located in the index you will get the\n`taskId` and an additional user-defined JSON blob that was indexed with\ntask. You can use this to store additional information you would like to\nget additional from the index.\n\n**Entry Expiration**, all indexed entries must have an expiration date.\nTypically this defaults to one year, if not specified. If you are\nindexing tasks to make it easy to find artifacts, consider using the\nexpiration date that the artifacts is assigned.\n\n**Indexing Routes**, tasks can be indexed using the API below, but the\nmost common way to index tasks is adding a custom route on the following\nform `index.<namespace>`. In-order to add this route to a task you'll\nneed the following scope `queue:route:index.<namespace>`. When a task has\nthis route, it'll be indexed when the task is **completed successfully**.\nThe task will be indexed with `rank`, `data` and `expires` as specified\nin `task.extra.index`, see example below:\n\n```js\n{\n  payload:  { /* ... */ },\n  routes: [\n    // index.<namespace> prefixed routes, tasks CC'ed such a route will\n    // be indexed under the given <namespace>\n    \"index.mozilla-central.linux-64.release-build\",\n    \"index.<revision>.linux-64.release-build\"\n  ],\n  extra: {\n    // Optional details for indexing service\n    index: {\n      // Ordering, this taskId will overwrite any thing that has\n      // rank <= 4000 (defaults to zero)\n      rank:       4000,\n\n      // Specify when the entries expires (Defaults to 1 year)\n      expires:          new Date().toJSON(),\n\n      // A little informal data to store along with taskId\n      // (less 16 kb when encoded as JSON)\n      data: {\n        hgRevision:   \"...\",\n        commitMessae: \"...\",\n        whatever...\n      }\n    },\n    // Extra properties for other services...\n  }\n  // Other task properties...\n}\n```\n\n**Remark**, when indexing tasks using custom routes, it's also possible\nto listen for messages about these tasks. Which is quite convenient, for\nexample one could bind to `route.index.mozilla-central.*.release-build`,\nand pick up all messages about release builds. Hence, it is a\ngood idea to document task index hierarchies, as these make up extension\npoints in their own.",
  "baseUrl": "https://index.taskcluster.net/v1",
  "entries": [
    {
      "type": "function",
      "method": "get",
      "route": "/task/<namespace>",
      "args": [
        "namespace"
      ],
      "name": "findTask",
      "title": "Find Indexed Task",
      "description": "Find task by namespace, if no task existing for the given namespace, this\nAPI end-point respond `404`.",
      "output": "http://schemas.taskcluster.net/index/v1/indexed-task-response.json#"
    },
    {
      "type": "function",
      "method": "post",
      "route": "/namespaces/<namespace>",
      "args": [
        "namespace"
      ],
      "name": "listNamespaces",
      "title": "List Namespaces",
      "description": "List the namespaces immediately under a given namespace. This end-point\nlist up to 1000 namespaces. If more namespaces are present a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
      "input": "http://schemas.taskcluster.net/index/v1/list-namespaces-request.json#",
      "output": "http://schemas.taskcluster.net/index/v1/list-namespaces-response.json#"
    },
    {
      "type": "function",
      "method": "post",
      "route": "/tasks/<namespace>",
      "args": [
        "namespace"
      ],
      "name": "listTasks",
      "title": "List Tasks",
      "description": "List the tasks immediately under a given namespace. This end-point\nlist up to 1000 tasks. If more tasks are present a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
      "input": "http://schemas.taskcluster.net/index/v1/list-tasks-request.json#",
      "output": "http://schemas.taskcluster.net/index/v1/list-tasks-response.json#"
    },
    {
      "type": "function",
      "method": "put",
      "route": "/task/<namespace>",
      "args": [
        "namespace"
      ],
      "name": "insertTask",
      "title": "Insert Task into Index",
      "description": "Insert a task into the index. Please see the introduction above, for how\nto index successfully completed tasks automatically, using custom routes.",
      "scopes": [
        [
          "index:insert-task:<namespace>"
        ]
      ],
      "input": "http://schemas.taskcluster.net/index/v1/insert-task-request.json#",
      "output": "http://schemas.taskcluster.net/index/v1/indexed-task-response.json#"
    },
    {
      "type": "function",
      "method": "get",
      "route": "/ping",
      "args": [],
      "name": "ping",
      "title": "Ping Server",
      "description": "Documented later...\n\n**Warning** this api end-point is **not stable**."
    }
  ]
}