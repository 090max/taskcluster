version: 2
migrationScript: |-
  begin
    create table clients_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table clients_entities add primary key (partition_key, row_key);

    create table roles_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table roles_entities add primary key (partition_key, row_key);

    create table taskcluster_github_builds_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_github_builds_entities add primary key (partition_key, row_key);

    create table taskcluster_intergration_owners_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_intergration_owners_entities add primary key (partition_key, row_key);

    create table taskcluster_checks_to_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_checks_to_tasks_entities add primary key (partition_key, row_key);

    create table taskcluster_check_runs_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_check_runs_entities add primary key (partition_key, row_key);

    create table hooks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table hooks_entities add primary key (partition_key, row_key);

    create table queues_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queues_entities add primary key (partition_key, row_key);

    create table last_fire3_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table last_fire3_entities add primary key (partition_key, row_key);

    create table indexed_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table indexed_tasks_entities add primary key (partition_key, row_key);

    create table namespaces_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table namespaces_entities add primary key (partition_key, row_key);

    create table denylisted_notification_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table denylisted_notification_entities add primary key (partition_key, row_key);

    create table cache_purges_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table cache_purges_entities add primary key (partition_key, row_key);

    create table queue_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_tasks_entities add primary key (partition_key, row_key);

    create table queue_artifcats_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_artifcats_entities add primary key (partition_key, row_key);

    create table queue_task_groups_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_groups_entities add primary key (partition_key, row_key);

    create table queue_task_group_active_sets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_group_active_sets_entities add primary key (partition_key, row_key);

    create table queue_task_requirement_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_requirement_entities add primary key (partition_key, row_key);

    create table queue_task_dependency_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_dependency_entities add primary key (partition_key, row_key);

    create table queue_worker_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_worker_entities add primary key (partition_key, row_key);

    create table queue_worker_type_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_worker_type_entities add primary key (partition_key, row_key);

    create table queue_provisioner_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_provisioner_entities add primary key (partition_key, row_key);

    create table secrets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table secrets_entities add primary key (partition_key, row_key);

    create table authorization_codes_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table authorization_codes_table_entities add primary key (partition_key, row_key);

    create table access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table access_token_table_entities add primary key (partition_key, row_key);

    create table session_storage_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table session_storage_table_entities add primary key (partition_key, row_key);

    create table github_access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table github_access_token_table_entities add primary key (partition_key, row_key);

    create table wm_workers_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wm_workers_entities add primary key (partition_key, row_key);

    create table wm_worker_pools_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wm_worker_pools_entities add primary key (partition_key, row_key);

    create table wm_worker_pool_errors_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wm_worker_pool_errors_entities add primary key (partition_key, row_key);

    grant select, insert, update, delete on clients_entities to $db_user_prefix$_auth;
    grant select, insert, update, delete on roles_entities to $db_user_prefix$_auth;

    grant select, insert, update, delete on taskcluster_check_runs_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_checks_to_tasks_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_github_builds_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_integration_owners_entities to $db_user_prefix$_github;

    grant select, insert, update, delete on hooks_entities to $db_user_prefix$_hooks;
    grant select, insert, update, delete on last_fire3_entities to $db_user_prefix$_hooks;
    grant select, insert, update, delete on queues_entities to $db_user_prefix$_hooks;

    grant select, insert, update, delete on indexed_tasks_entities to $db_user_prefix$_index;
    grant select, insert, update, delete on namespaces_entities to $db_user_prefix$_index;

    grant select, insert, update, delete on denylisted_notification_entities to $db_user_prefix$_notify;

    grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge-cache;

    grant select, insert, update, delete on secrets_entities to $db_user_prefix$_secrets;

    grant select, insert, update, delete on access_token_table_entities to $db_user_prefix$_web-server;
    grant select, insert, update, delete on authorization_codes_table_entities to $db_user_prefix$_web-server;
    grant select, insert, update, delete on github_access_token_table_entities to $db_user_prefix$_web-server;
    grant select, insert, update, delete on session_storage_table_entities to $db_user_prefix$_web-server;

    grant select, insert, update, delete on wm_worker_pool_errors_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on wm_worker_pools_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on wm_workers_entities to $db_user_prefix$_worker-manager;

    grant select, insert, update, delete on queue_tasks_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_artifacts_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_task_groups_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_task_group_members_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_task_group_active_sets_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_task_requirement_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_task_dependency_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_worker_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_worker_type_entities to $db_user_prefix$_worker-manager;
    grant select, insert, update, delete on queue_provisioner_entities to $db_user_prefix$_worker-manager;
  end
methods:
  clients_entities_load:
    description: test
    mode: read
    serviceName: auth
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version,
        clients_entities.etag from clients_entities
        where clients_entities.partition_key = clients_entities_load.partition_key and clients_entities.row_key = clients_entities_load.row_key;
      end
  clients_entities_create:
    serviceName: auth
    description: test
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into clients_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, clients_entities_create.version, new_etag)
          where clients_entities.partition_key = clients_entities_create.pk and clients_entities.row_key = clients_entities_create.rk;
        else
          insert into clients_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  clients_entities_remove:
    serviceName: auth
    description: test
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from clients_entities
        where clients_entities.partition_key = clients_entities_remove.partition_key and clients_entities.row_key = clients_entities_remove.row_key
        returning clients_entities.etag;
      end
  clients_entities_modify:
    serviceName: auth
    description: |
      Modify an entity. If the modify operation is succesful, the etag is returned in a set.
      Else, an error will be raised with the following error code:
      * 'P0004' - update was unsuccessful (e.g., the etag value did not match)
      * 'P0002' - entry not found in the table (i.e., no such row)
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update clients_entities
        set (value, version, etag) = (properties, clients_entities_modify.version, new_etag)
        where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key and clients_entities.etag = clients_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform clients_entities.etag from clients_entities
        where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  clients_entities_scan:
    description: test
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if clients_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);
        end if;

        if clients_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
